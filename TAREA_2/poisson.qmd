---
title: "Distribuci√≥n Poisson"
lang: es
---

```{=html}
<style>
main.content {
text-align: justify}
</style>
```

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
library(knitr)
library(gridExtra)
library(patchwork)

```

## Introducci√≥n

La distribuci√≥n de Poisson es una de las distribuciones de probabilidad discretas m√°s importantes en estad√≠stica y tiene una amplia gama de aplicaciones en diversas disciplinas. Fue desarrollada por el matem√°tico franc√©s Sim√©on Denis Poisson en 1837 como una extensi√≥n del trabajo de Abraham de Moivre sobre la distribuci√≥n binomial.

Esta distribuci√≥n es especialmente √∫til para modelar el **n√∫mero de eventos que ocurren en un intervalo fijo** de tiempo, espacio, volumen, o cualquier otra unidad de medida, cuando estos eventos:

-   Ocurren de manera **independiente**
-   Tienen una **tasa promedio constante**
-   Es **raro** que ocurran m√∫ltiples eventos simult√°neamente

### Aplicaciones Comunes

La distribuci√≥n de Poisson se utiliza frecuentemente para modelar:

-   **Llegadas de clientes** a un banco o restaurante por hora
-   **Llamadas telef√≥nicas** recibidas en un centro de atenci√≥n por minuto
-   **Defectos de fabricaci√≥n** en un lote de productos
-   **Accidentes de tr√°fico** en una intersecci√≥n por d√≠a
-   **Mutaciones gen√©ticas** en una secuencia de ADN
-   **Part√≠culas radioactivas** detectadas por un contador Geiger
-   **Terremotos** en una regi√≥n geogr√°fica por a√±o

La distribuci√≥n de Poisson tambi√©n surge como **aproximaci√≥n a la distribuci√≥n binomial** cuando $n$ es grande y $p$ es peque√±o, manteniendo $np$ constante.

## Definici√≥n

::: {#def-poisson}
Una variable aleatoria $X$ sigue una **distribuci√≥n de Poisson** con par√°metro $\lambda$ si cuenta el n√∫mero de eventos que ocurren en un intervalo fijo, donde $\lambda$ representa la tasa promedio de ocurrencia de eventos en ese intervalo. La funci√≥n de masa de probabilidad de la distribuci√≥n de Poisson est√° dada por:

$$f(x)= \frac{\lambda^x e^{-\lambda}}{x!}$$

donde:

-   $x = 0, 1, 2, 3, \ldots$ (n√∫mero entero no negativo de eventos)
-   $\lambda > 0$ (par√°metro de tasa)
-   $e \approx 2.71828$ (base del logaritmo natural)

A una variable aleatoria que sigue esta distribuci√≥n se le denota como $X \sim \text{Poisson}(\lambda)$
:::

## Caracter√≠sticas

**Par√°metros**

La distribuci√≥n de Poisson tiene un √∫nico par√°metro:

-   $\lambda$ (lambda): Tasa promedio de eventos por unidad de medida ($\lambda > 0$)

    -   Tambi√©n representa tanto la media como la varianza de la distribuci√≥n
    -   Es un n√∫mero real positivo
    -   Sus unidades dependen del contexto (eventos/hora, defectos/lote, etc.)

**Par√°metros Estad√≠sticos**

Una caracter√≠stica notable de la distribuci√≥n de Poisson es que su **media y varianza son iguales**:

Media (Esperanza):

$$E(X) = \lambda$$

Varianza:

$$\text{Var}(X) = \lambda$$

Desviaci√≥n est√°ndar:

$$\sigma = \sqrt{\lambda}$$

Coeficiente de variaci√≥n:

$$CV = \frac{\sigma}{\mu} = \frac{\sqrt{\lambda}}{\lambda} = \frac{1}{\sqrt{\lambda}}$$

**Funci√≥n de Distribuci√≥n (Probabilidad Acumulada)**

La funci√≥n de distribuci√≥n acumulada (CDF) es:

$$F(x) = P(X \leq x) = \sum_{i=0}^{x} \frac{\lambda^i e^{-\lambda}}{i!}$$

Esta suma no tiene una forma cerrada simple, por lo que generalmente se calcula num√©ricamente o se consulta en tablas estad√≠sticas.

## Ejemplo B√°sico

Un centro de atenci√≥n telef√≥nica recibe en promedio 4 llamadas por minuto. Suponiendo que las llamadas siguen un proceso de Poisson, responde las siguientes preguntas:

a)  ¬øCu√°l es la probabilidad de recibir exactamente 6 llamadas en un minuto?
b)  ¬øCu√°l es la probabilidad de no recibir ninguna llamada en un minuto?
c)  ¬øCu√°l es la probabilidad de recibir 3 o menos llamadas en un minuto?

**Identificaci√≥n del modelo:**

-   Variable: $X$ = n√∫mero de llamadas por minuto
-   Distribuci√≥n: $X \sim \text{Poisson}(\lambda = 4)$

```{r ejemplo-basico}
# Par√°metro
lambda <- 4

# a) P(X = 6)
prob_6 <- dpois(6, lambda)
cat("a) P(X = 6) =", round(prob_6, 4))

# Verificaci√≥n manual
prob_6_manual <- (lambda^6 * exp(-lambda)) / factorial(6)
cat("\n   Verificaci√≥n manual:", round(prob_6_manual, 4))

# b) P(X = 0)
prob_0 <- dpois(0, lambda)
cat("\n\nb) P(X = 0) =", round(prob_0, 4))

# c) P(X ‚â§ 3)
prob_3_o_menos <- ppois(3, lambda)
cat("\n\nc) P(X ‚â§ 3) =", round(prob_3_o_menos, 4))

# Verificaci√≥n manual para c)
prob_3_manual <- sum(dpois(0:3, lambda))
cat("\n   Verificaci√≥n manual:", round(prob_3_manual, 4))
```

**Interpretaci√≥n de Resultados**

```{r interpretacion-ejemplo}

cat("a) La probabilidad de recibir exactamente 6 llamadas en un minuto es", 
    round(prob_6, 6), "\n")

cat("b) La probabilidad de no recibir ninguna llamada en un minuto es", 
    round(prob_0 , 6), "\n")

cat("c) La probabilidad de recibir 3 o menos llamadas en un minuto es", 
    round(prob_3_o_menos, 6), "\n\n")

# Estad√≠sticas adicionales
media <- lambda
varianza <- lambda
desv_std <- sqrt(lambda)

cat("Estad√≠sticas de la distribuci√≥n:\n")
cat("Media:", media, "llamadas por minuto\n")
cat("Varianza:", varianza, "\n")
cat("Desviaci√≥n est√°ndar:", round(desv_std, 2), "llamadas por minuto\n")
```

**Gr√°fica de la Distribuci√≥n del Ejemplo**

```{r grafico-ejemplo, fig.cap="Distribuci√≥n de Poisson para el ejemplo (Œª = 4)"}
# Valores para graficar
k_vals <- 0:12
prob_vals <- dpois(k_vals, lambda)

# Data frame para ggplot
data_ejemplo <- data.frame(k = k_vals, probabilidad = prob_vals)

# Resaltar los valores del ejemplo
data_ejemplo$color <- "Normal"
data_ejemplo$color[data_ejemplo$k == 6] <- "P(X = 6)"
data_ejemplo$color[data_ejemplo$k == 0] <- "P(X = 0)"
data_ejemplo$color[data_ejemplo$k <= 3] <- ifelse(data_ejemplo$color[data_ejemplo$k <= 3] == "Normal", 
                                                 "P(X ‚â§ 3)", data_ejemplo$color[data_ejemplo$k <= 3])

# Gr√°fico
ggplot(data_ejemplo, aes(x = k, y = probabilidad, fill = color)) +
  geom_col(alpha = 0.8, width = 0.7) +
  labs(title = "Distribuci√≥n de Poisson: Llamadas Telef√≥nicas",
       subtitle = "Œª = 4 llamadas por minuto",
       x = "N√∫mero de llamadas (k)",
       y = "Probabilidad P(X = k)",
       fill = "Casos del ejemplo") +
  theme_minimal() +
  scale_fill_manual(values = c("Normal" = "#BDC3C7", 
                              "P(X = 6)" = "#E74C3C", 
                              "P(X = 0)" = "#3498DB",
                              "P(X ‚â§ 3)" = "#2ECC71")) +
  scale_x_continuous(breaks = k_vals) +
  theme(legend.position = "bottom")
```

## Comparaci√≥n: Efecto del Par√°metro $\lambda$

El par√°metro $\lambda$ controla tanto la **posici√≥n central** como la **dispersi√≥n** de la distribuci√≥n de Poisson.

```{r efecto-lambda, fig.cap="Efecto del par√°metro Œª en la distribuci√≥n de Poisson"}
# Diferentes valores de lambda
lambda_values <- c(1, 3, 5, 10)

# Rango de k para cada lambda
k_max <- max(lambda_values) + 3 * sqrt(max(lambda_values))
k_vals <- 0:ceiling(k_max)

# Crear data frame para todos los valores
data_lambda <- expand.grid(k = k_vals, lambda = lambda_values)
data_lambda$probabilidad <- dpois(data_lambda$k, data_lambda$lambda)
data_lambda$lambda_label <- paste("Œª =", data_lambda$lambda)
data_lambda$lambda_label <- factor(data_lambda$lambda_label, levels = c("Œª = 1", "Œª = 3", "Œª = 5", "Œª = 10"))


# Gr√°fico comparativo
ggplot(data_lambda, aes(x = k, y = probabilidad, fill = lambda_label)) +
  geom_col(alpha = 0.7, position = "identity") +
  facet_wrap(~lambda_label, scales = "free") +
  labs(title = "Efecto del Par√°metro Œª en la Distribuci√≥n de Poisson",
       subtitle = "A mayor Œª, la distribuci√≥n se desplaza hacia la derecha y se dispersa m√°s",
       x = "N√∫mero de eventos (k)",
       y = "Probabilidad P(X = k)") +
  theme_minimal() +
  theme(legend.position = "none") +
  scale_fill_brewer(type = "qual", palette = "Set1")
```

**Comparaci√≥n Superpuesta**

```{r comparacion-superpuesta, fig.cap="Comparaci√≥n superpuesta de diferentes valores de Œª"}
# Limitar k para mejor visualizaci√≥n
k_vals_plot <- 0:20

# Filtrar datos
data_plot <- data_lambda[data_lambda$k <= 20, ]

# Gr√°fico superpuesto
ggplot(data_plot, aes(x = k, y = probabilidad, color = lambda_label)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2) +
  labs(title = "Comparaci√≥n de Distribuciones de Poisson",
       subtitle = "Diferentes valores del par√°metro Œª",
       x = "N√∫mero de eventos (k)",
       y = "Probabilidad P(X = k)",
       color = "Par√°metro Œª") +
  theme_minimal() +
  scale_color_brewer(type = "qual", palette = "Set1") +
  theme(legend.position = "bottom")
```

**Tabla Comparativa de Par√°metros Estad√≠sticos**

```{r tabla-parametros}
# Crear tabla con estad√≠sticas para diferentes lambdas
lambdas_tabla <- c(0.5, 1, 2, 3, 5, 8, 10, 15)

tabla_stats <- data.frame(
  Lambda = lambdas_tabla,
  Media = lambdas_tabla,
  Varianza = lambdas_tabla,
  Desv_Std = sqrt(lambdas_tabla),
  CV = 1/sqrt(lambdas_tabla),
  P_X_eq_0 = dpois(0, lambdas_tabla)
)



kable(tabla_stats, digits = 4,
      caption = "Par√°metros estad√≠sticos para diferentes valores de Œª",
      col.names = c("Œª", "Media", "Varianza", "Desv. Std.", "CV", "P(X=0)"))
```

## Simulaci√≥n de Valores Poisson y Comparaci√≥n con la Te√≥rica

Consideremos una simulaci√≥n con $\lambda = 3.5$ y $n = 15,000$.

```{r simulacion-basica}
# Par√°metros para la simulaci√≥n
lambda <- 3.5
n_sim <- 15000

# Simulaci√≥n de valores
set.seed(42)
valores_simulados <- rpois(n_sim, lambda)

# Estad√≠sticas de la simulaci√≥n
media_sim <- mean(valores_simulados)
var_sim <- var(valores_simulados)
sd_sim <- sd(valores_simulados)

# Valores te√≥ricos
media_teorica <- lambda
var_teorica <- lambda
sd_teorica <- sqrt(lambda)

# Tabla comparativa
comparacion <- data.frame(
  Estad√≠stica = c("Media", "Varianza", "Desv. Est√°ndar"),
  Te√≥rica = c(media_teorica, var_teorica, sd_teorica),
  Simulada = c(media_sim, var_sim, sd_sim),
  Diferencia = c(abs(media_teorica - media_sim), 
                 abs(var_teorica - var_sim), 
                 abs(sd_teorica - sd_sim)),
  Error_Relativo = c(abs(media_teorica - media_sim)/media_teorica * 100,
                     abs(var_teorica - var_sim)/var_teorica * 100,
                     abs(sd_teorica - sd_sim)/sd_teorica * 100)
)

kable(comparacion, digits = 4, 
      caption = paste("Comparaci√≥n te√≥rica vs simulada (Œª =", lambda, ", n =", format(n_sim, big.mark = ",")),
      col.names = c("Estad√≠stica", "Te√≥rica", "Simulada", "Diferencia", "Error Rel. (%)"))
```

**Comparaci√≥n Gr√°fica: Simulaci√≥n vs Te√≥rica**

```{r grafico-comparacion, fig.cap="Comparaci√≥n entre distribuci√≥n te√≥rica y simulada de Poisson"}
# Rango de valores para comparar
k_max <- quantile(valores_simulados, 0.99)
k_vals <- 0:k_max

# Probabilidades te√≥ricas
prob_teorica <- dpois(k_vals, lambda)

# Frecuencias relativas de la simulaci√≥n
freq_tabla <- table(factor(valores_simulados, levels = k_vals))
freq_relativa <- as.numeric(freq_tabla) / n_sim

# Crear data frame para ggplot
data_comp <- data.frame(
  k = rep(k_vals, 2),
  Probabilidad = c(prob_teorica, freq_relativa),
  Tipo = rep(c("Te√≥rica", "Simulada"), each = length(k_vals))
)

# Gr√°fico de barras comparativo
ggplot(data_comp, aes(x = k, y = Probabilidad, fill = Tipo)) +
  geom_col(position = "dodge", alpha = 0.7, width = 0.8) +
  scale_x_continuous(breaks = seq(0, k_max, by = 1)) +
  labs(title = "Distribuci√≥n de Poisson: Te√≥rica vs Simulada",
       subtitle = paste("Œª =", lambda, ", n =", format(n_sim, big.mark = ",")),
       x = "N√∫mero de eventos (k)",
       y = "Probabilidad / Frecuencia relativa",
       fill = "Distribuci√≥n") +
  theme_minimal() +
  theme(legend.position = "top") +
  scale_fill_manual(values = c("Te√≥rica" = "#3498DB", "Simulada" = "#E74C3C")) 
  
```

## Verificaci√≥n de la Suma de Variables Poisson Independientes

::: {#thm-suma-poisson}
Si $X_1 \sim \text{Poisson}(\lambda_1)$ y $X_2 \sim \text{Poisson}(\lambda_2)$ son independientes, entonces:

$$Y = X_1 + X_2 \sim \text{Poisson}(\lambda_1 + \lambda_2)$$

**Generalizaci√≥n:** Si $X_1, X_2, \ldots, X_n$ son variables Poisson independientes con par√°metros $\lambda_1, \lambda_2, \ldots, \lambda_n$, entonces:

$$\sum_{i=1}^n X_i \sim \text{Poisson}\left(\sum_{i=1}^n \lambda_i\right)$$
:::

### Verificaci√≥n por Simulaci√≥n: Caso de Dos Variables

```{r suma-dos-poisson}
# Par√°metros para las dos variables Poisson
lambda1 <- 2.5
lambda2 <- 4.2
lambda_suma <- lambda1 + lambda2
n_sim_suma <- 12000

set.seed(123)

# M√©todo 1: Generar dos Poisson independientes y sumarlas
X1 <- rpois(n_sim_suma, lambda1)
X2 <- rpois(n_sim_suma, lambda2)
suma_simulada <- X1 + X2

# M√©todo 2: Generar directamente de Poisson(Œª‚ÇÅ + Œª‚ÇÇ)
poisson_directa <- rpois(n_sim_suma, lambda_suma)

# Comparar estad√≠sticas
stats_suma <- data.frame(
  M√©todo = c("X‚ÇÅ + X‚ÇÇ (Suma)", "Poisson Directa", "Te√≥rico"),
  Media = c(mean(suma_simulada), mean(poisson_directa), lambda_suma),
  Varianza = c(var(suma_simulada), var(poisson_directa), lambda_suma),
  Desv_Std = c(sd(suma_simulada), sd(poisson_directa), sqrt(lambda_suma)),
  Min = c(min(suma_simulada), min(poisson_directa), 0),
  Max = c(max(suma_simulada), max(poisson_directa), NA)
)

kable(stats_suma, digits = 4,
      caption = paste("Verificaci√≥n suma de Poisson (Œª‚ÇÅ =", lambda1, ", Œª‚ÇÇ =", lambda2, ")"))

# Informaci√≥n adicional
cat("\nPAR√ÅMETROS INDIVIDUALES:\n")
cat("========================\n")
cat("X‚ÇÅ ~ Poisson(", lambda1, "): E(X‚ÇÅ) =", lambda1, ", Var(X‚ÇÅ) =", lambda1, "\n")
cat("X‚ÇÇ ~ Poisson(", lambda2, "): E(X‚ÇÇ) =", lambda2, ", Var(X‚ÇÇ) =", lambda2, "\n\n")

cat("SUMA TE√ìRICA:\n")
cat("=============\n")
cat("Y = X‚ÇÅ + X‚ÇÇ ~ Poisson(", lambda_suma, ")\n")
cat("E[Y] = E(X‚ÇÅ) + E(X‚ÇÇ) =", lambda_suma, "\n")
cat("Var(Y) = Var(X‚ÇÅ) + Var(X‚ÇÇ) =", lambda_suma, " (por independencia)\n")
```

**Comparaci√≥n Visual de las Distribuciones**

```{r comparacion-visual-suma, fig.cap="Comparaci√≥n visual: Suma de Poisson vs Poisson directa"}
# Crear data frame para comparaci√≥n
data_suma_comp <- data.frame(
  valores = c(suma_simulada, poisson_directa),
  metodo = rep(c("X1 + X2", "Poisson(Œª1+Œª2)"), each = n_sim_suma)
)

# Histogramas superpuestos
ggplot(data_suma_comp, aes(x = valores, fill = metodo)) +
  geom_histogram(alpha = 0.6, binwidth = 1, position = "dodge2", center =0) +
  scale_x_continuous(breaks = seq(0, max(c(suma_simulada, poisson_directa)), by = 1)) +
  labs(title = "Verificaci√≥n de la Propiedad Aditiva de Poisson",
       subtitle = paste("Œª1 =", lambda1, ", Œª2 =", lambda2, ", Œª1+Œª2 =", lambda_suma),
       x = "N√∫mero de eventos",
       y = "Frecuencia",
       fill = "M√©todo") +
  theme_minimal() +
  theme(legend.position = "top") +
  scale_fill_manual(values = c("X1 + X2" = "#3498DB", "Poisson(Œª1+Œª2)" = "#E74C3C"))
```

### Verificaci√≥n con M√∫ltiples Variables

```{r suma-multiples, fig.cap="Verificaci√≥n con suma de m√∫ltiples variables Poisson"}
# Suma de 4 variables Poisson independientes
lambdas <- c(1.5, 2.0, 2.5, 3.0)
lambda_total <- sum(lambdas)
n_vars <- length(lambdas)

# Generar las variables individuales
variables_poisson <- matrix(0, nrow = n_sim_suma, ncol = n_vars)
for(i in 1:n_vars) {
  variables_poisson[, i] <- rpois(n_sim_suma, lambdas[i])
}

# Suma de las 4 variables
suma_multiple <- rowSums(variables_poisson)

# Poisson directa con Œª total
poisson_multiple_directa <- rpois(n_sim_suma, lambda_total)

# Estad√≠sticas comparativas
cat("VERIFICACI√ìN CON", n_vars, "VARIABLES POISSON\n")
cat("Œª‚ÇÅ =", lambdas[1], ", Œª‚ÇÇ =", lambdas[2], ", Œª‚ÇÉ =", lambdas[3], ", Œª‚ÇÑ =", lambdas[4], "\n")
cat("Œª_total =", lambda_total, "\n\n")

stats_multiple <- data.frame(
  Distribuci√≥n = c("Suma de 4 Poisson", "Poisson(Œª_total)", "Diferencia"),
  Media = c(mean(suma_multiple), mean(poisson_multiple_directa), 
            abs(mean(suma_multiple) - mean(poisson_multiple_directa))),
  Varianza = c(var(suma_multiple), var(poisson_multiple_directa),
               abs(var(suma_multiple) - var(poisson_multiple_directa)))
)

kable(stats_multiple, digits = 4, 
      caption = "Estad√≠sticas para suma de m√∫ltiples variables Poisson")

# Visualizaci√≥n
data_multiple <- data.frame(
  valores = c(suma_multiple, poisson_multiple_directa),
  tipo = rep(c("Suma de 4 Poisson", "Poisson(Œª_total)"), each = n_sim_suma)
)

ggplot(data_multiple, aes(x = valores, fill = tipo)) +
  geom_histogram(alpha = 0.6, binwidth = 1, center=0, position = "dodge2") +
  scale_x_continuous(breaks = seq(0, max(c(suma_multiple, poisson_multiple_directa)), by = 1)) +
  labs(title = "Suma de M√∫ltiples Variables Poisson",
       subtitle = paste("Œª_total =", lambda_total),
       x = "N√∫mero de eventos",
       y = "Frecuencia",
       fill = "Tipo") +
  theme_minimal() +
  scale_fill_manual(values = c("#2ECC71", "#F39C12"))
```

## Teorema Central del L√≠mite con Variables Poisson

**Configuraci√≥n del Experimento**

Consideremos una variable aleatoria $X \sim \text{Poisson}(\lambda = 3)$. Vamos a generar m√∫ltiples muestras de diferentes tama√±os y observar c√≥mo se comporta la distribuci√≥n de la media muestral $\bar{X}$.

**Teor√≠a esperada:**

-   Para muestras de tama√±o $n$ de $X \sim \text{Poisson}(\lambda)$
-   $\bar{X} \sim N\left(\lambda, \frac{\lambda}{n}\right)$ cuando $n$ es grande
-   $E(\bar{X}) = \lambda$ y $\text{Var}(\bar{X}) = \frac{\lambda}{n}$

```{r configuracion-tcl}
# Par√°metros del experimento
lambda_tcl <- 3
tama√±os_muestra <- c(5, 10, 25, 50, 100)
num_muestras <- 2000

cat("CONFIGURACI√ìN DEL EXPERIMENTO\n")
cat("=============================\n")
cat("Distribuci√≥n original: Poisson(Œª =", lambda_tcl, ")\n")
cat("Tama√±os de muestra:", paste(tama√±os_muestra, collapse = ", "), "\n")
cat("N√∫mero de muestras por tama√±o:", num_muestras, "\n\n")

cat("Par√°metros te√≥ricos de la distribuci√≥n original:\n")
cat("E[X] =", lambda_tcl, "\n")
cat("Var(X) =", lambda_tcl, "\n")
cat("SD(X) =", round(sqrt(lambda_tcl), 3), "\n")
```

**Generaci√≥n de Muestras y C√°lculo de Medias**

```{r generacion-muestras}
# Funci√≥n para generar medias muestrales
generar_medias_muestrales <- function(n, num_muestras, lambda) {
  medias <- numeric(num_muestras)
  for(i in 1:num_muestras) {
    muestra <- rpois(n, lambda)
    medias[i] <- mean(muestra)
  }
  return(medias)
}

# Generar medias para cada tama√±o de muestra
set.seed(123)
medias_muestrales <- list()

for(i in seq_along(tama√±os_muestra)) {
  n <- tama√±os_muestra[i]
  medias_muestrales[[i]] <- generar_medias_muestrales(n, num_muestras, lambda_tcl)
  names(medias_muestrales)[i] <- paste("n", n, sep = "_")
}

# Crear data frame para an√°lisis
data_tcl <- do.call(rbind, lapply(seq_along(medias_muestrales), function(i) {
  data.frame(
    media_muestral = medias_muestrales[[i]],
    n = tama√±os_muestra[i],
    n_label = paste("n =", tama√±os_muestra[i])
  )
}))

data_tcl$n_label <- factor(data_tcl$n_label, levels = c("n = 5", "n = 10", "n = 25", "n = 50", "n = 100"))

cat("Muestras generadas exitosamente.\n")
cat("Total de observaciones:", nrow(data_tcl), "\n")
```

**Verificaci√≥n de Convergencia de Media y Varianza**

```{r verificacion-convergencia}
# Calcular estad√≠sticas para cada tama√±o de muestra
estadisticas_tcl <- data.frame(
  n = tama√±os_muestra,
  Media_Observada = sapply(medias_muestrales, mean),
  Media_Teorica = rep(lambda_tcl, length(tama√±os_muestra)),
  Var_Observada = sapply(medias_muestrales, var),
  Var_Teorica = lambda_tcl / tama√±os_muestra,
  SD_Observada = sapply(medias_muestrales, sd),
  SD_Teorica = sqrt(lambda_tcl / tama√±os_muestra)
)

# Calcular errores

estadisticas_tcl <- estadisticas_tcl |> mutate(
  Error_Media = abs(Media_Observada - Media_Teorica),
  Error_Var = abs(Var_Observada - Var_Teorica),
  Error_SD = abs(SD_Observada - SD_Teorica))

kable(estadisticas_tcl, digits = 4,
      caption = "Convergencia de estad√≠sticos de la media muestral",
      col.names = c("n", "Media Obs.", "Media Te√≥r.", "Var. Obs.", "Var. Te√≥r.", 
                   "SD Obs.", "SD Te√≥r.", "Error Media", "Error Var.", "Error SD"))

```

**Visualizaci√≥n de la Convergencia**

```{r}
visualizacion-convergencia, fig.cap="Distribuci√≥n de medias muestrales para diferentes tama√±os de muestra"}
# Histogramas de las medias muestrales
ggplot(data_tcl, aes(x = media_muestral)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, alpha = 0.7, fill = "#3498DB") +
  geom_vline(xintercept = lambda_tcl, color = "#E74C3C", linetype = "dashed", linewidth = 1) +
  facet_wrap(~n_label, scales = "free_y") +
  labs(title = "Distribuci√≥n de Medias Muestrales (TCL)",
       subtitle = paste("Distribuci√≥n original: Poisson(Œª =", lambda_tcl, "). L√≠nea roja: media te√≥rica"),
       x = "Media muestral",
       y = "Densidad") +
  theme_minimal()
```

```{r comparacion-con-normal, fig.cap="Comparaci√≥n con distribuci√≥n normal te√≥rica"}
# Agregar curvas normales espec√≠ficas para cada panel
data_tcl_split <- split(data_tcl, data_tcl$n_label)

plots_comparacion <- lapply(names(data_tcl_split), function(label) {
  datos <- data_tcl_split[[label]]
  n_val <- unique(datos$n)
  
  ggplot(datos, aes(x = media_muestral)) +
    geom_histogram(aes(y = after_stat(density)), bins = 25, alpha = 0.6, fill = "#3498DB") +
    stat_function(fun = dnorm, 
                  args = list(mean = lambda_tcl, sd = sqrt(lambda_tcl/n_val)), 
                  color = "#E74C3C", linewidth = 1.2) +
    ggtitle(label) +
    xlab("Media muestral") +
    ylab("Densidad") +
    theme_minimal()
})

# Combinar gr√°ficos
do.call(grid.arrange, c(plots_comparacion, ncol = 3))
```

## Aplicaciones de la Distribuci√≥n de Poisson

### Gesti√≥n de Tr√°fico de Red

**Contexto:** Una empresa de telecomunicaciones monitorea el tr√°fico de datos en sus servidores. El n√∫mero de paquetes de datos que llegan por segundo sigue una distribuci√≥n de Poisson.

```{r aplicacion-trafico}
# Par√°metros del problema
lambda_trafico <- 8.5  # 8.5 paquetes por segundo en promedio

cat("APLICACI√ìN 1: TR√ÅFICO DE RED\n")
cat("============================\n")
cat("Par√°metro: Œª =", lambda_trafico, "paquetes por segundo\n\n")

# Preguntas t√≠picas
cat("AN√ÅLISIS DEL TR√ÅFICO:\n")

# 1. Probabilidad de recibir exactamente 10 paquetes en un segundo
prob_10 <- dpois(10, lambda_trafico)
cat("1. P(X = 10 paquetes) =", round(prob_10, 4), "(", round(prob_10*100, 2), "%)\n")

# 2. Probabilidad de recibir m√°s de 12 paquetes
prob_mas_12 <- 1 - ppois(12, lambda_trafico)
cat("2. P(X > 12 paquetes) =", round(prob_mas_12, 4), "(", round(prob_mas_12*100, 2), "%)\n")

# 3. N√∫mero esperado de paquetes en 5 segundos
# En 5 segundos: Y ~ Poisson(5Œª)
lambda_5seg <- 5 * lambda_trafico
paquetes_5seg_esperados <- lambda_5seg
cat("3. Paquetes esperados en 5 segundos =", paquetes_5seg_esperados, "\n")

# 4. Probabilidad de sobrecarga (m√°s de 15 paquetes por segundo)
prob_sobrecarga <- 1 - ppois(15, lambda_trafico)
cat("4. P(Sobrecarga) = P(X > 15) =", round(prob_sobrecarga, 4), "\n")

# Simulaci√≥n para verificar
set.seed(456)
n_sim_trafico <- 10000
sim_paquetes <- rpois(n_sim_trafico, lambda_trafico)

cat("\nVERIFICACI√ìN POR SIMULACI√ìN (n =", format(n_sim_trafico, big.mark = ","), "):\n")
cat("Media simulada:", round(mean(sim_paquetes), 3), "(te√≥rica:", lambda_trafico, ")\n")
cat("P(X = 10) simulada:", round(mean(sim_paquetes == 10), 4), "(te√≥rica:", round(prob_10, 4), ")\n")
cat("P(X > 15) simulada:", round(mean(sim_paquetes > 15), 4), "(te√≥rica:", round(prob_sobrecarga, 4), ")\n")
```

```{r grafico-trafico, fig.cap="Distribuci√≥n del tr√°fico de red y zonas cr√≠ticas"}
# Visualizaci√≥n del problema de tr√°fico
k_trafico <- 0:20
prob_trafico <- dpois(k_trafico, lambda_trafico)

data_trafico <- data.frame(
  paquetes = k_trafico,
  probabilidad = prob_trafico
)

# Definir zonas
data_trafico$zona <- case_when(
  data_trafico$paquetes <= 5 ~ "Bajo",
  data_trafico$paquetes <= 12 ~ "Normal", 
  data_trafico$paquetes <= 15 ~ "Alto",
  TRUE ~ "Sobrecarga"
)

ggplot(data_trafico, aes(x = paquetes, y = probabilidad, fill = zona)) +
  geom_col(alpha = 0.8) +
  labs(title = "Distribuci√≥n del Tr√°fico de Red por Segundo",
       subtitle = paste("Œª =", lambda_trafico, "paquetes/segundo"),
       x = "N√∫mero de paquetes",
       y = "Probabilidad",
       fill = "Zona de tr√°fico") +
  theme_minimal() +
  scale_fill_manual(values = c("Bajo" = "#2ECC71", "Normal" = "#3498DB", 
                              "Alto" = "#F39C12", "Sobrecarga" = "#E74C3C"))
```

### Control de Calidad Industrial

**Contexto:** Una f√°brica de semiconductores monitorea defectos en sus productos. El n√∫mero de defectos por lote sigue una distribuci√≥n de Poisson.

```{r aplicacion-calidad}
# Par√°metros del control de calidad
lambda_defectos <- 2.3  # 2.3 defectos por lote en promedio

cat("APLICACI√ìN 2: CONTROL DE CALIDAD\n")
cat("================================\n")
cat("Par√°metro: Œª =", lambda_defectos, "defectos por lote\n\n")

# An√°lisis de calidad
cat("AN√ÅLISIS DE CONTROL DE CALIDAD:\n")

# 1. Probabilidad de lote perfecto (0 defectos)
prob_perfecto <- dpois(0, lambda_defectos)
cat("1. P(Lote perfecto) = P(X = 0) =", round(prob_perfecto, 4), "(", round(prob_perfecto*100, 1), "%)\n")

# 2. Probabilidad de lote aceptable (‚â§ 3 defectos)
prob_aceptable <- ppois(3, lambda_defectos)
cat("2. P(Lote aceptable) = P(X ‚â§ 3) =", round(prob_aceptable, 4), "(", round(prob_aceptable*100, 1), "%)\n")

# 3. Probabilidad de rechazo (> 5 defectos)
prob_rechazo <- 1 - ppois(5, lambda_defectos)
cat("3. P(Rechazo) = P(X > 5) =", round(prob_rechazo, 4), "(", round(prob_rechazo*100, 1), "%)\n")

# 4. An√°lisis econ√≥mico
costo_defecto <- 50  # $50 por defecto
defectos_esperados <- lambda_defectos
costo_esperado_lote <- defectos_esperados * costo_defecto
cat("4. Costo esperado por defectos por lote: $", costo_esperado_lote, "\n")

# 5. An√°lisis de m√∫ltiples lotes
n_lotes <- 100
lambda_total <- n_lotes * lambda_defectos
cat("5. Defectos esperados en", n_lotes, "lotes:", lambda_total, "\n")

```

```{r simulacion-calidad, fig.cap="Simulaci√≥n del proceso de control de calidad"}
# Simulaci√≥n del proceso de control de calidad
set.seed(789)
n_lotes_sim <- 1000
lotes_simulados <- rpois(n_lotes_sim, lambda_defectos)

# Clasificar lotes
clasificacion <- case_when(
  lotes_simulados == 0 ~ "Perfecto",
  lotes_simulados <= 3 ~ "Aceptable",
  lotes_simulados <= 5 ~ "Revisi√≥n",
  TRUE ~ "Rechazo"
)

# Crear data frame para visualizaci√≥n
data_calidad <- data.frame(
  defectos = lotes_simulados,
  clasificacion = factor(clasificacion, 
                        levels = c("Perfecto", "Aceptable", "Revisi√≥n", "Rechazo"))
)

# Gr√°fico de la simulaci√≥n
ggplot(data_calidad, aes(x = defectos, fill = clasificacion)) +
  geom_histogram(bins = 15, alpha = 0.8, position = "stack") +
  labs(title = "Simulaci√≥n de Control de Calidad",
       subtitle = paste("n =", format(n_lotes_sim, big.mark = ","), "lotes simulados"),
       x = "N√∫mero de defectos por lote",
       y = "Frecuencia",
       fill = "Clasificaci√≥n") +
  theme_minimal() +
  scale_fill_manual(values = c("Perfecto" = "#2ECC71", "Aceptable" = "#3498DB",
                              "Revisi√≥n" = "#F39C12", "Rechazo" = "#E74C3C"))

# Tabla de resultados de la simulaci√≥n
tabla_clasificacion <- table(clasificacion)
prop_clasificacion <- prop.table(tabla_clasificacion)

cat("\nRESULTADOS DE LA SIMULACI√ìN:\n")
cat("============================\n")
for(i in 1:length(tabla_clasificacion)) {
  cat(names(tabla_clasificacion)[i], ":", tabla_clasificacion[i], 
      "lotes (", round(prop_clasificacion[i]*100, 1), "%)\n")
}
```

### Epidemiolog√≠a y Salud P√∫blica

**Contexto:** Un epidemi√≥logo estudia la incidencia de una enfermedad rara en una poblaci√≥n. Los nuevos casos por semana siguen una distribuci√≥n de Poisson.

```{r aplicacion-epidemiologia}
# Par√°metros epidemiol√≥gicos
lambda_casos <- 4.2  # 4.2 casos nuevos por semana en promedio

cat("APLICACI√ìN 3: EPIDEMIOLOG√çA\n")
cat("===========================\n")
cat("Par√°metro: Œª =", lambda_casos, "casos nuevos por semana\n\n")

cat("AN√ÅLISIS EPIDEMIOL√ìGICO:\n")

# 1. Probabilidad de semana sin casos nuevos
prob_sin_casos <- dpois(0, lambda_casos)
cat("1. P(Semana sin casos) =", round(prob_sin_casos, 4), "(", round(prob_sin_casos*100, 1), "%)\n")

# 2. Probabilidad de brote (m√°s de 8 casos)
prob_brote <- 1 - ppois(8, lambda_casos)
cat("2. P(Brote) = P(X > 8) =", round(prob_brote, 4), "(", round(prob_brote*100, 1), "%)\n")

# 3. Casos esperados en un mes (4 semanas)
casos_mes <- 4 * lambda_casos
cat("3. Casos esperados en un mes:", casos_mes, "\n")

# 4. An√°lisis de intervenci√≥n
# Si una intervenci√≥n reduce Œª en 30%
lambda_intervencion <- lambda_casos * 0.7
reduccion_casos_mes <- (lambda_casos - lambda_intervencion) * 4
cat("4. Con intervenci√≥n (reducci√≥n 30%):\n")
cat("   Nuevos casos esperados por semana:", lambda_intervencion, "\n")
cat("   Reducci√≥n esperada por mes:", reduccion_casos_mes, "casos\n")

# 5. Monitoreo de alertas
umbral_alerta <- 7
prob_alerta <- 1 - ppois(umbral_alerta - 1, lambda_casos)
cat("5. P(Alerta) = P(X ‚â•", umbral_alerta, ") =", round(prob_alerta, 4), "\n")
```

```{r visualizacion-epidemiologia, fig.cap="An√°lisis epidemiol√≥gico con y sin intervenci√≥n"}
# Comparaci√≥n antes y despu√©s de intervenci√≥n
k_epi <- 0:15
prob_antes <- dpois(k_epi, lambda_casos)
prob_despues <- dpois(k_epi, lambda_intervencion)

data_epi <- data.frame(
  casos = rep(k_epi, 2),
  probabilidad = c(prob_antes, prob_despues),
  escenario = rep(c("Sin intervenci√≥n", "Con intervenci√≥n"), each = length(k_epi))
)

ggplot(data_epi, aes(x = casos, y = probabilidad, fill = escenario)) +
  geom_col(position = "dodge", alpha = 0.8) +
  geom_vline(xintercept = umbral_alerta - 0.5, linetype = "dashed", color = "red") +
  labs(title = "Impacto de Intervenci√≥n en Salud P√∫blica",
       subtitle = paste("Reducci√≥n del 30% en la incidencia (Œª:", lambda_casos, "‚Üí", lambda_intervencion, ")"),
       x = "N√∫mero de casos nuevos por semana",
       y = "Probabilidad",
       fill = "Escenario",
       caption = "L√≠nea roja: umbral de alerta") +
  theme_minimal() +
  scale_fill_manual(values = c("Sin intervenci√≥n" = "#E74C3C", "Con intervenci√≥n" = "#2ECC71"))
```

## Ejercicios Propuestos

::: {#exr-centro-atencion}
Un centro de atenci√≥n telef√≥nica recibe llamadas siguiendo una distribuci√≥n de Poisson con una tasa promedio de 6 llamadas por minuto.

**Preguntas:**

a)  ¬øCu√°l es la probabilidad de recibir exactamente 4 llamadas en un minuto?

b)  ¬øCu√°l es la probabilidad de no recibir ninguna llamada en 30 segundos?

c)  ¬øCu√°l es el n√∫mero esperado de llamadas en una hora?

d)  ¬øCu√°l es la probabilidad de recibir entre 8 y 12 llamadas (inclusive) en dos minutos?
:::

```{r}
# Distribuci√≥n de Poisson: Centro de Atenci√≥n Telef√≥nica
# Tasa promedio: Œª = 6 llamadas por minuto

# ============================================
# 1. Probabilidad de recibir exactamente 4 llamadas en un minuto
# ============================================
lambda_1min <- 6
prob_4_llamadas <- dpois(4, lambda = lambda_1min)
cat("1. P(X = 4 llamadas en 1 minuto) =", prob_4_llamadas, "\n")
cat("   Porcentaje:", round(prob_4_llamadas * 100, 2), "%\n\n")

# ============================================
# 2. Probabilidad de NO recibir ninguna llamada en 30 segundos
# ============================================
# En 30 segundos (0.5 minutos), Œª = 6 * 0.5 = 3
lambda_30seg <- 6 * 0.5
prob_0_llamadas <- dpois(0, lambda = lambda_30seg)
cat("2. P(X = 0 llamadas en 30 segundos) =", prob_0_llamadas, "\n")
cat("   Porcentaje:", round(prob_0_llamadas * 100, 2), "%\n\n")

# ============================================
# 3. N√∫mero esperado de llamadas en una hora
# ============================================
# En una hora (60 minutos), Œª = 6 * 60 = 360
esperado_1hora <- 6 * 60
cat("3. N√∫mero esperado de llamadas en 1 hora =", esperado_1hora, "llamadas\n\n")

# ============================================
# 4. Probabilidad de recibir entre 8 y 12 llamadas (inclusive) en 2 minutos
# ============================================
# En 2 minutos, Œª = 6 * 2 = 12
lambda_2min <- 6 * 2
prob_8_a_12 <- sum(dpois(8:12, lambda = lambda_2min))
# Alternativamente: ppois(12, lambda_2min) - ppois(7, lambda_2min)
cat("4. P(8 ‚â§ X ‚â§ 12 llamadas en 2 minutos) =", prob_8_a_12, "\n")
cat("   Porcentaje:", round(prob_8_a_12 * 100, 2), "%\n\n")
```

::: {#exr-linea_prod}
Una l√≠nea de producci√≥n tiene en promedio 1.5 defectos por cada 100 productos fabricados.

**Preguntas:**

a)  Si se fabrican 500 productos, ¬øcu√°l es la probabilidad de tener exactamente 8 defectos?

b)  ¬øCu√°l es la probabilidad de tener 10 o m√°s defectos en 500 productos?

c)  ¬øCu√°ntos productos se deben fabricar para que la probabilidad de tener al menos un defecto sea de 0.95?

d)  Si la empresa mejora el proceso y reduce los defectos a 1.2 por cada 100 productos, ¬øcu√°l ser√≠a la nueva probabilidad de tener 10 o m√°s defectos en 500 productos?
:::

```{r}
# Distribuci√≥n de Poisson: Defectos en L√≠nea de Producci√≥n
# Tasa promedio: 1.5 defectos por cada 100 productos

# ============================================
# A. Probabilidad de tener exactamente 8 defectos en 500 productos
# ============================================
# Tasa para 500 productos: Œª = 1.5 * (500/100) = 1.5 * 5 = 7.5
lambda_500 <- 1.5 * (500/100)
prob_8_defectos <- dpois(8, lambda = lambda_500)
cat("1. P(X = 8 defectos en 500 productos) =", prob_8_defectos, "\n")
cat("   Porcentaje:", round(prob_8_defectos * 100, 2), "%\n\n")

# ============================================
# B. Probabilidad de tener 10 o m√°s defectos en 500 productos
# ============================================
# P(X ‚â• 10) = 1 - P(X ‚â§ 9)
prob_10_o_mas <- 1 - ppois(9, lambda = lambda_500)
# Alternativamente: ppois(9, lambda_500, lower.tail = FALSE)
cat("2. P(X ‚â• 10 defectos en 500 productos) =", prob_10_o_mas, "\n")
cat("   Porcentaje:", round(prob_10_o_mas * 100, 2), "%\n\n")

# ============================================
# C. Productos necesarios para P(X ‚â• 1) = 0.95
# ============================================
# P(X ‚â• 1) = 1 - P(X = 0) = 0.95
# P(X = 0) = 0.05
# e^(-Œª) = 0.05
# Œª = -ln(0.05)

lambda_requerido <- -log(0.05)
# Œª = 1.5 * (n/100), entonces n = Œª * 100 / 1.5
productos_necesarios <- lambda_requerido * 100 / 1.5
cat("3. Productos necesarios para P(X ‚â• 1) = 0.95:\n")
cat("   Œª requerido =", round(lambda_requerido, 4), "\n")
cat("   Productos =", round(productos_necesarios, 2), "\n")
cat("   (aproximadamente", ceiling(productos_necesarios), "productos)\n\n")

# Verificaci√≥n
lambda_verificacion <- 1.5 * (ceiling(productos_necesarios)/100)
prob_verificacion <- 1 - dpois(0, lambda = lambda_verificacion)
cat("   Verificaci√≥n: P(X ‚â• 1) =", round(prob_verificacion, 4), "\n\n")

# ============================================
# D. Nueva probabilidad con mejora (1.2 defectos por 100 productos)
# ============================================
# Nueva tasa para 500 productos: Œª = 1.2 * (500/100) = 6
lambda_500_nuevo <- 1.2 * (500/100)
prob_10_o_mas_nuevo <- 1 - ppois(9, lambda = lambda_500_nuevo)
cat("4. Con mejora (1.2 defectos/100):\n")
cat("   Nueva Œª para 500 productos =", lambda_500_nuevo, "\n")
cat("   P(X ‚â• 10 defectos en 500 productos) =", prob_10_o_mas_nuevo, "\n")
cat("   Porcentaje:", round(prob_10_o_mas_nuevo * 100, 2), "%\n\n")

```

::: {#exr-hospital}
El servicio de urgencias de un hospital recibe pacientes seg√∫n un proceso de Poisson con una tasa promedio de 2.5 pacientes por hora durante la noche.

**Preguntas:**

a)  ¬øCu√°l es la probabilidad de que lleguen exactamente 3 pacientes en una hora?

b)  ¬øCu√°l es la probabilidad de que no llegue ning√∫n paciente en 2 horas consecutivas?

c)  El hospital tiene capacidad para atender 8 pacientes por turno de 4 horas. ¬øCu√°l es la probabilidad de superar esta capacidad?

d)  ¬øCu√°l deber√≠a ser la capacidad m√≠nima para que la probabilidad de saturaci√≥n sea menor al 10% en un turno de 4 horas?
:::

```{r}

# Distribuci√≥n de Poisson: Servicio de Urgencias
# Tasa promedio: Œª = 2.5 pacientes por hora

# ============================================
# A. Probabilidad de que lleguen exactamente 3 pacientes en una hora
# ============================================
lambda_1hora <- 2.5
prob_3_pacientes <- dpois(3, lambda = lambda_1hora)
cat("1. P(X = 3 pacientes en 1 hora) =", prob_3_pacientes, "\n\n")

# ============================================
# B. Probabilidad de que no llegue ning√∫n paciente en 2 horas consecutivas
# ============================================
lambda_2horas <- 2.5 * 2
prob_0_pacientes <- dpois(0, lambda = lambda_2horas)
cat("2. P(X = 0 pacientes en 2 horas) =", prob_0_pacientes, "\n\n")

# ============================================
# C. Probabilidad de superar la capacidad de 8 pacientes en 4 horas
# ============================================
lambda_4horas <- 2.5 * 4
prob_mas_de_8 <- 1 - ppois(8, lambda = lambda_4horas)
cat("3. P(X > 8 pacientes en 4 horas) =", prob_mas_de_8, "\n\n")

# ============================================
# D. Capacidad m√≠nima para que P(saturaci√≥n) < 0.10 en 4 horas
# ============================================
# Buscamos k tal que P(X > k) < 0.10, es decir, P(X ‚â§ k) ‚â• 0.90
capacidad_minima <- qpois(0.90, lambda = lambda_4horas)
prob_verificacion <- 1 - ppois(capacidad_minima, lambda = lambda_4horas)
cat("4. Capacidad m√≠nima para P(saturaci√≥n) < 10%:\n")
cat("   Capacidad =", capacidad_minima, "pacientes\n")
cat("   Verificaci√≥n: P(X >", capacidad_minima, ") =", prob_verificacion, "\n")
```

::: {#exr-tcl_poisson}
Implementa una verificaci√≥n completa del Teorema Central del L√≠mite para una distribuci√≥n Poisson con $\lambda = 7$.
:::

```{r}
# Verificaci√≥n del Teorema Central del L√≠mite para Poisson(Œª=7)

# Par√°metros
lambda <- 7
tama√±os_muestra <- c(5, 10, 30, 50, 100)
num_simulaciones <- 10000

# Configurar gr√°ficos
par(mfrow=c(3,2))

# Para cada tama√±o de muestra
for (n in tama√±os_muestra) {
  
  # Generar medias muestrales
  medias_muestrales <- replicate(num_simulaciones, {
    muestra <- rpois(n, lambda)
    mean(muestra)
  })
  
  # Par√°metros te√≥ricos de la distribuci√≥n normal
  media_teorica <- lambda
  desv_teorica <- sqrt(lambda / n)
  
  # Histograma con curva normal te√≥rica
  hist(medias_muestrales, 
       breaks = 30, 
       probability = TRUE,
       main = paste("TCL: n =", n),
       xlab = "Media muestral",
       ylab = "Densidad",
       col = "lightblue",
       border = "white")
  
  # Curva normal te√≥rica
  x_vals <- seq(min(medias_muestrales), max(medias_muestrales), length=100)
  lines(x_vals, dnorm(x_vals, media_teorica, desv_teorica), 
        col = "red", lwd = 2)
  
  # Agregar leyenda
  legend("topright", 
         legend = c(paste("Media =", round(mean(medias_muestrales), 3)),
                    paste("DE =", round(sd(medias_muestrales), 3)),
                    paste("Te√≥rica: Œº =", media_teorica),
                    paste("Te√≥rica: œÉ =", round(desv_teorica, 3))),
         cex = 0.7)
}

par(mfrow=c(1,1))

# ============================================
# Prueba de normalidad Shapiro-Wilk
# ============================================
cat("\n========== PRUEBAS DE NORMALIDAD (Shapiro-Wilk) ==========\n\n")

for (n in tama√±os_muestra) {
  medias_muestrales <- replicate(num_simulaciones, {
    muestra <- rpois(n, lambda)
    mean(muestra)
  })
  
  # Test de Shapiro-Wilk (usar muestra de las medias)
  muestra_test <- sample(medias_muestrales, min(5000, num_simulaciones))
  test_shapiro <- shapiro.test(muestra_test)
  
  cat("n =", n, ":\n")
  cat("  Media observada:", round(mean(medias_muestrales), 4), 
      "  (te√≥rica:", lambda, ")\n")
  cat("  DE observada:", round(sd(medias_muestrales), 4), 
      "  (te√≥rica:", round(sqrt(lambda/n), 4), ")\n")
  cat("  Shapiro-Wilk p-value:", format.pval(test_shapiro$p.value), "\n\n")
}

# ============================================
# Q-Q plots para verificar normalidad
# ============================================
par(mfrow=c(2,3))

for (n in tama√±os_muestra) {
  medias_muestrales <- replicate(num_simulaciones, {
    muestra <- rpois(n, lambda)
    mean(muestra)
  })
  
  # Estandarizar
  medias_estandarizadas <- (medias_muestrales - lambda) / sqrt(lambda/n)
  
  qqnorm(medias_estandarizadas, 
         main = paste("Q-Q Plot: n =", n),
         col = "blue", 
         pch = 20,
         cex = 0.5)
  qqline(medias_estandarizadas, col = "red", lwd = 2)
}

par(mfrow=c(1,1))

# ============================================
# Tabla resumen
# ============================================
cat("\n========== TABLA RESUMEN ==========\n\n")
cat(sprintf("%-10s %-15s %-15s %-15s %-15s\n", 
            "n", "Media Obs.", "Media Te√≥rica", "DE Obs.", "DE Te√≥rica"))
cat(paste(rep("-", 70), collapse=""), "\n")

for (n in tama√±os_muestra) {
  medias_muestrales <- replicate(num_simulaciones, {
    muestra <- rpois(n, lambda)
    mean(muestra)
  })
  
  cat(sprintf("%-10d %-15.4f %-15.4f %-15.4f %-15.4f\n",
              n, 
              mean(medias_muestrales), 
              lambda,
              sd(medias_muestrales),
              sqrt(lambda/n)))
}

# ============================================
# Verificaci√≥n del error est√°ndar
# ============================================
cat("\n========== CONVERGENCIA DEL ERROR EST√ÅNDAR ==========\n\n")

for (n in tama√±os_muestra) {
  medias_muestrales <- replicate(num_simulaciones, {
    muestra <- rpois(n, lambda)
    mean(muestra)
  })
  
  error_observado <- sd(medias_muestrales)
  error_teorico <- sqrt(lambda/n)
  diferencia_porcentual <- abs(error_observado - error_teorico) / error_teorico * 100
  
  cat("n =", n, ":\n")
  cat("  Error est√°ndar observado:", round(error_observado, 5), "\n")
  cat("  Error est√°ndar te√≥rico:", round(error_teorico, 5), "\n")
  cat("  Diferencia porcentual:", round(diferencia_porcentual, 2), "%\n\n")
}

# ============================================
# Gr√°fico de convergencia
# ============================================
errores_obs <- numeric(length(tama√±os_muestra))
errores_teo <- numeric(length(tama√±os_muestra))

for (i in 1:length(tama√±os_muestra)) {
  n <- tama√±os_muestra[i]
  medias_muestrales <- replicate(num_simulaciones, {
    muestra <- rpois(n, lambda)
    mean(muestra)
  })
  errores_obs[i] <- sd(medias_muestrales)
  errores_teo[i] <- sqrt(lambda/n)
}

plot(tama√±os_muestra, errores_obs, 
     type = "b", col = "blue", lwd = 2, pch = 19,
     ylim = range(c(errores_obs, errores_teo)),
     main = "Convergencia del Error Est√°ndar (TCL)",
     xlab = "Tama√±o de muestra (n)",
     ylab = "Error est√°ndar",
     log = "x")
lines(tama√±os_muestra, errores_teo, 
      type = "b", col = "red", lwd = 2, pch = 17)
legend("topright", 
       legend = c("Observado", "Te√≥rico (‚àö(Œª/n))"),
       col = c("blue", "red"), 
       lwd = 2, 
       pch = c(19, 17))
grid()
```

::: {#exr-prop_aditiva}
Verifica por simulaci√≥n que si $X_1 \sim \text{Poisson}(3.5)$ y $X_2 \sim \text{Poisson}(2.8)$ son independientes, entonces $X_1 + X_2 \sim \text{Poisson}(6.3)$.

**Pasos espec√≠ficos:**

a)  Generar 10,000 muestras de cada distribuci√≥n y calcule su suma
b)  Comparar las estad√≠sticas de la suma con una Poisson(6.3) directa
c)  Extienda la verificaci√≥n a la suma de 4 variables Poisson independientes
:::

```{r}
# ==============================================================================
# Verificaci√≥n por Simulaci√≥n de la Suma de Variables de Poisson Independientes
# ==============================================================================

## 1. Definici√≥n de Par√°metros de la Simulaci√≥n ‚öôÔ∏è
N_muestras <- 10000 # N√∫mero de muestras a generar para la simulaci√≥n
lambda1 <- 3.5      # Par√°metro para X1 ~ Poisson(lambda1)
lambda2 <- 2.8      # Par√°metro para X2 ~ Poisson(lambda2)
lambda_suma_teorico <- lambda1 + lambda2 # 6.3

# ==============================================================================
## 2. Simulaci√≥n para la Suma de Dos Variables (X1 + X2)
# ==============================================================================

# Generar 10,000 muestras para X1 y X2
X1 <- rpois(N_muestras, lambda = lambda1)
X2 <- rpois(N_muestras, lambda = lambda2)

# Calcular la suma
Suma_Simulada_2var <- X1 + X2

# Generar 10,000 muestras de la distribuci√≥n te√≥rica de la suma (Poisson(6.3))
Suma_Teorica_2var <- rpois(N_muestras, lambda = lambda_suma_teorico)


# ==============================================================================
## 3. Comparaci√≥n de Estad√≠sticas y Distribuciones (2 Variables) üìä
# ==============================================================================

# --- A. Estad√≠sticas Descriptivas ---

cat("--- Resultados de la Simulaci√≥n para X1 + X2 ---\n")
cat(paste("N = ", N_muestras, " muestras. Teorema: Suma ~ Poisson(", lambda_suma_teorico, ")\n\n", sep=""))

# Comparaci√≥n de Medias (La media debe ser aproximadamente lambda_suma_teorico = 6.3)
media_simulada <- mean(Suma_Simulada_2var)
media_teorica_sim <- mean(Suma_Teorica_2var) # Para ver qu√© tan cerca est√° la simulaci√≥n directa
media_teorica_valor <- lambda_suma_teorico

cat(sprintf("Media Te√≥rica (lambda):        %.4f\n", media_teorica_valor))
cat(sprintf("Media de la Suma Simulada:     %.4f\n", media_simulada))
cat(sprintf("Media de la Poisson(6.3) Dir.: %.4f\n\n", media_teorica_sim))

# Comparaci√≥n de Varianzas (La varianza debe ser aproximadamente lambda_suma_teorico = 6.3)
varianza_simulada <- var(Suma_Simulada_2var)
varianza_teorica_sim <- var(Suma_Teorica_2var)
varianza_teorica_valor <- lambda_suma_teorico

cat(sprintf("Varianza Te√≥rica (lambda):     %.4f\n", varianza_teorica_valor))
cat(sprintf("Varianza de la Suma Simulada:  %.4f\n", varianza_simulada))
cat(sprintf("Varianza de la Poisson(6.3) Dir.: %.4f\n\n", varianza_teorica_sim))


# --- B. Gr√°fico de Comparaci√≥n de Densidades (Distribuci√≥n de Frecuencias) ---

# Crear un marco de datos para el histograma
max_val <- max(c(Suma_Simulada_2var, Suma_Teorica_2var))
breaks_vec <- seq(0, max_val + 1, by = 1)

# Histograma normalizado (frecuencias relativas) para la suma simulada
hist_sim <- hist(Suma_Simulada_2var, breaks = breaks_vec, plot = FALSE)
prob_sim <- hist_sim$counts / N_muestras
valores_sim <- hist_sim$mids

# Probabilidades te√≥ricas de la Poisson(6.3)
prob_teoricas <- dpois(valores_sim, lambda = lambda_suma_teorico)

# El siguiente bloque genera el gr√°fico para visualizaci√≥n:
# ====================================================================
plot(valores_sim, prob_sim,
     type = "h", # 'h' para l√≠neas de histograma
     lwd = 5,
     col = "#0072B250", # Azul semitransparente
     main = "Comparaci√≥n de Distribuci√≥n: Suma Simulada vs. Poisson Te√≥rica",
     xlab = "Valor de la Variable (k)",
     ylab = "Probabilidad (Frecuencia Relativa)",
     ylim = c(0, max(prob_sim, prob_teoricas) * 1.05))

# Agregar las probabilidades te√≥ricas como puntos rojos
points(valores_sim, prob_teoricas,
       pch = 19, # Punto s√≥lido
       col = "#D55E00", # Rojo-naranja
       cex = 0.8) # Tama√±o del punto

legend("topright",
       legend = c("Suma Simulada (X1+X2)", paste("Poisson Te√≥rica (", lambda_suma_teorico, ")", sep="")),
       col = c("#0072B2", "#D55E00"),
       lwd = c(5, NA),
       pch = c(NA, 19),
       bty = "n") # Ocultar el recuadro
# ====================================================================


# ==============================================================================
## 4. Extensi√≥n a la Suma de Cuatro Variables (X1 + X2 + X3 + X4) ‚ûï4Ô∏è‚É£
# ==============================================================================

cat("\n--- Extensi√≥n: Simulaci√≥n para X1 + X2 + X3 + X4 ---\n")

# Definici√≥n de par√°metros para las 4 variables
lambda3 <- 1.0
lambda4 <- 1.5
lambda_suma_4var_teorico <- lambda1 + lambda2 + lambda3 + lambda4 # 3.5 + 2.8 + 1.0 + 1.5 = 8.8

# Generar muestras para las variables adicionales
X3 <- rpois(N_muestras, lambda = lambda3)
X4 <- rpois(N_muestras, lambda = lambda4)

# Calcular la suma de las 4 variables
Suma_Simulada_4var <- X1 + X2 + X3 + X4

# --- Comparaci√≥n de Estad√≠sticas (4 Variables) ---

cat(paste("N = ", N_muestras, " muestras. Teorema: Suma ~ Poisson(", lambda_suma_4var_teorico, ")\n\n", sep=""))

# Comparaci√≥n de Medias (Debe ser aproximadamente lambda_suma_4var_teorico = 8.8)
media_simulada_4var <- mean(Suma_Simulada_4var)
cat(sprintf("Media Te√≥rica (lambda):        %.4f\n", lambda_suma_4var_teorico))
cat(sprintf("Media de la Suma Simulada:     %.4f\n\n", media_simulada_4var))

# Comparaci√≥n de Varianzas (Debe ser aproximadamente lambda_suma_4var_teorico = 8.8)
varianza_simulada_4var <- var(Suma_Simulada_4var)
cat(sprintf("Varianza Te√≥rica (lambda):     %.4f\n", lambda_suma_4var_teorico))
cat(sprintf("Varianza de la Suma Simulada:  %.4f\n", varianza_simulada_4var))

# ==============================================================================
# Conclusi√≥n
# Los valores simulados de la media y la varianza son muy cercanos al par√°metro
# te√≥rico de la distribuci√≥n de Poisson resultante, verificando el teorema:
# Si $X_i \sim \text{Poisson}(\lambda_i)$ son independientes, entonces
# $\sum X_i \sim \text{Poisson}(\sum \lambda_i)$.
# ==============================================================================
```

::: {#exr-aplicacion_web}
Un sitio web recibe en promedio 15 visitantes por minuto durante las horas pico. El servidor puede manejar hasta 25 solicitudes simult√°neas sin degradaci√≥n del rendimiento.

**An√°lisis requerido:**

a)  ¬øCu√°l es la probabilidad de que en un minuto el servidor experimente degradaci√≥n?

b)  Si se duplica la capacidad del servidor (50 solicitudes), ¬øc√≥mo cambia la probabilidad de degradaci√≥n?

c)  ¬øCu√°l ser√≠a la capacidad √≥ptima del servidor para que la probabilidad de degradaci√≥n sea menor al 1%?

d)  Simule el comportamiento del servidor durante una hora (60 minutos) y calcule el porcentaje de tiempo con degradaci√≥n.
:::

```{r}
# ==============================================================================
# AN√ÅLISIS DE RENDIMIENTO DEL SERVIDOR USANDO DISTRIBUCI√ìN POISSON
# Tasa de llegada (lambda): 15 visitantes/minuto
# ==============================================================================

## 1. Definici√≥n de Par√°metros ‚öôÔ∏è
lambda <- 15 # Tasa promedio de visitantes por minuto
capacidad_inicial <- 25 # L√≠mite inicial del servidor
capacidad_duplicada <- 50 # L√≠mite duplicado del servidor
prob_objetivo <- 0.01 # Probabilidad de degradaci√≥n deseada (1%)

cat("--- Par√°metros del An√°lisis ---\n")
cat(sprintf("Tasa promedio de llegadas (lambda): %.1f visitantes/min\n", lambda))
cat(sprintf("Capacidad inicial del servidor: %d solicitudes\n", capacidad_inicial))
cat("----------------------------------\n\n")

# La degradaci√≥n ocurre si X > Capacidad

# ==============================================================================
## 2. Probabilidad de Degradaci√≥n con Capacidad de 25 üìâ
# ==============================================================================

cat("## 2. Probabilidad de Degradaci√≥n con Capacidad = 25\n")

# P(Degradaci√≥n) = P(X > 25) = 1 - P(X <= 25)
prob_degradacion1 <- 1 - ppois(capacidad_inicial, lambda = lambda)

cat(sprintf("Probabilidad Acumulada P(X <= 25): %.4f\n", ppois(capacidad_inicial, lambda = lambda)))
cat(sprintf("Probabilidad de Degradaci√≥n P(X > 25): %.4f (o %.2f%%)\n",
            prob_degradacion1, prob_degradacion1 * 100))
cat("----------------------------------\n\n")


# ==============================================================================
## 3. Probabilidad de Degradaci√≥n con Capacidad de 50 ‚è´
# ==============================================================================

cat("## 3. Probabilidad de Degradaci√≥n con Capacidad = 50\n")

# P(Degradaci√≥n) = P(X > 50) = 1 - P(X <= 50)
prob_degradacion2 <- 1 - ppois(capacidad_duplicada, lambda = lambda)

cat(sprintf("Probabilidad Acumulada P(X <= 50): %.12f\n", ppois(capacidad_duplicada, lambda = lambda)))
cat(sprintf("Probabilidad de Degradaci√≥n P(X > 50): %.2e\n", prob_degradacion2))
cat(sprintf("(Esto es aproximadamente %.15f o casi 0%%)\n", prob_degradacion2))
cat("----------------------------------\n\n")


# ==============================================================================
## 4. Capacidad √ìptima para P(Degradaci√≥n) < 1% üéØ
# ==============================================================================

cat("## 4. Capacidad √ìptima para P(Degradaci√≥n) < 1%%\n")

# Buscamos la capacidad C tal que P(X > C) < 0.01
# Esto es equivalente a buscar C tal que P(X <= C) > 0.99
prob_complementaria <- 1 - prob_objetivo # 0.99

# Usamos la funci√≥n de cuantil (qpois) para encontrar el valor
capacidad_optima_qpois <- qpois(prob_complementaria, lambda = lambda)

# Verificaci√≥n del valor inmediatamente inferior y superior (para la condici√≥n estricta)
prob_verif_inferior <- 1 - ppois(capacidad_optima_qpois - 1, lambda = lambda)
prob_verif_optima <- 1 - ppois(capacidad_optima_qpois, lambda = lambda)

cat(sprintf("Cuantil P(X <= C) >= 0.99: C = %d\n", capacidad_optima_qpois))
cat(sprintf("Verificaci√≥n con C = %d: P(X > %d) = %.4f (No cumple el < 1%%)\n",
            capacidad_optima_qpois, capacidad_optima_qpois, prob_verif_optima))

# El valor que cumple estrictamente P(X > C) < 0.01 es el siguiente entero
capacidad_optima_ajustada <- capacidad_optima_qpois + 1
prob_verif_ajustada <- 1 - ppois(capacidad_optima_ajustada, lambda = lambda)

cat(sprintf("Capacidad √ìptima (ajustada): C = %d\n", capacidad_optima_ajustada))
cat(sprintf("Verificaci√≥n con C = %d: P(X > %d) = %.4f (S√ç cumple el < 1%%)\n",
            capacidad_optima_ajustada, capacidad_optima_ajustada, prob_verif_ajustada))
cat("----------------------------------\n\n")


# ==============================================================================
## 5. Simulaci√≥n del Comportamiento del Servidor (60 Minutos) ‚è±Ô∏è
# ==============================================================================

cat("## 5. Simulaci√≥n de Comportamiento (1 Hora = 60 Minutos)\n")

N_minutos <- 60 # Minutos a simular
capacidad_simulacion <- 25 # Usando la capacidad inicial

# 1. Generar la llegada de visitantes para cada minuto (Poisson(15))
set.seed(42) # Para asegurar que los resultados sean reproducibles
visitantes_por_minuto <- rpois(N_minutos, lambda = lambda)

# 2. Determinar en qu√© minutos hubo degradaci√≥n (Visitantes > 25)
degradacion_minutos <- visitantes_por_minuto > capacidad_simulacion

# 3. Contar y calcular el porcentaje de tiempo con degradaci√≥n
minutos_con_degradacion <- sum(degradacion_minutos)
porcentaje_degradacion_simulada <- (minutos_con_degradacion / N_minutos) * 100

cat(sprintf("Minutos simulados: %d\n", N_minutos))
cat(sprintf("Minutos con Degradaci√≥n (Visitantes > %d): %d minutos\n",
            capacidad_simulacion, minutos_con_degradacion))
cat(sprintf("Porcentaje de Tiempo con Degradaci√≥n: %.2f%%\n", porcentaje_degradacion_simulada))

# Comparaci√≥n del resultado simulado con el te√≥rico
prob_teorica <- 1 - ppois(capacidad_simulacion, lambda = lambda)
cat(sprintf("Probabilidad Te√≥rica de Degradaci√≥n: %.2f%%\n", prob_teorica * 100))
cat("----------------------------------\n\n")

# ==============================================================================
# 6. Visualizaci√≥n de la Distribuci√≥n (Bloque de C√≥digo Corregido)
# ==============================================================================

# Generar una distribuci√≥n de Poisson te√≥rica para el gr√°fico
# Aseg√∫rate de que estas variables existen en tu entorno:
lambda <- 15 
capacidad_simulacion <- 25 
x_vals <- 0:35 # Aseguramos un rango amplio para incluir X > 25
prob_teorica_dpois <- dpois(x_vals, lambda = lambda)

# 1. Crear el primer barplot y GUARDAR las coordenadas (posiciones X)
# El argumento 'ylim' es crucial para asegurar que haya espacio para todas las barras
posiciones_x <- barplot(prob_teorica_dpois,
                        names.arg = x_vals,
                        xlab = "N√∫mero de Visitantes por Minuto (k)",
                        ylab = "P(X=k)",
                        main = "Distribuci√≥n de Poisson (lambda=15)",
                        col = "#0072B2", # Azul para Operaci√≥n Normal
                        ylim = c(0, max(prob_teorica_dpois) * 1.1) # Ajustar Y para visualizaci√≥n
)

# 2. Definir los √≠ndices para la degradaci√≥n (X > 25)
# El √≠ndice 1 corresponde a x_vals[1] = 0. El √≠ndice 27 corresponde a x_vals[27] = 26
indices_degradacion <- which(x_vals > capacidad_simulacion)

# 3. Resaltar la zona de degradaci√≥n usando las posiciones X guardadas
# Usamos 'posiciones_x' para asegurar que las barras a√±adidas coincidan exactamente.
barplot(prob_teorica_dpois[indices_degradacion],
        names.arg = x_vals[indices_degradacion],
        col = "#D55E00", # Rojo para la zona de degradaci√≥n
        add = TRUE,
        at = posiciones_x[indices_degradacion], # USAR POSICIONES X GUARDADAS
        width = 1)

# 4. Agregar la leyenda
legend("topright",
       legend = c(paste0("Operaci√≥n Normal (X \u2264 ", capacidad_simulacion, ")"),
                  paste0("Degradaci√≥n (X > ", capacidad_simulacion, ")")),
       fill = c("#0072B2", "#D55E00"),
       bty = "n") # Sin caja alrededor de la leyenda
```

::: {#exr-inventarios}
Una tienda registra que el n√∫mero de cierto producto vendido por d√≠a sigue una distribuci√≥n Poisson con $\lambda = 8$.

**Problemas de optimizaci√≥n:**

a)  Si la tienda mantiene un inventario de 12 unidades al inicio del d√≠a, ¬øcu√°l es la probabilidad de quedarse sin existencias?

b)  ¬øCu√°ntas unidades debe tener para que la probabilidad de agotarse sea menor al 5%?

c)  Calcule el costo esperado diario si:

    -   Cada unidad no vendida cuesta \$2 mantenerla en inventario
    -   Cada venta perdida por falta de stock cuesta \$15
    -   El costo de adquisici√≥n es \$10 por unidad

d)  Determine el nivel √≥ptimo de inventario que minimiza el costo total esperado.
:::

```{r}
# ==============================================================================
# OPTIMIZACI√ìN DE INVENTARIO POISSON
# ==============================================================================

# Par√°metro de la distribuci√≥n de Poisson
lambda <- 8

cat("--- Par√°metros del Problema ---\n")
cat(sprintf("Demanda: X ~ Poisson(lambda=%.0f)\n", lambda))
cat("--------------------------------\n\n")

## a. Probabilidad de Quedarse sin Existencias (Inventario de 12)
S_a <- 12
prob_agotamiento_a <- 1 - ppois(S_a, lambda = lambda)

cat("## a. Probabilidad de Agotarse con S = 12\n")
cat(sprintf("P(X > 12) = 1 - P(X <= 12) = 1 - %.4f\n", ppois(S_a, lambda = lambda)))
cat(sprintf("Probabilidad de Agotamiento: %.4f (%.2f%%)\n", prob_agotamiento_a, prob_agotamiento_a * 100))
cat("--------------------------------\n\n")

## b. Nivel de Inventario para P(Agotamiento) < 5%
prob_objetivo <- 0.05
prob_acumulada_minima <- 1 - prob_objetivo # 0.95

# Usar qpois(0.95, lambda=8)
S_b <- qpois(prob_acumulada_minima, lambda = lambda)

cat("## b. Nivel de Inventario para P(Agotamiento) < 5%\n")
cat(sprintf("Buscamos S tal que P(X <= S) >= %.4f\n", prob_acumulada_minima))
cat(sprintf("Nivel de Inventario M√≠nimo (S): %d unidades\n", S_b))
cat(sprintf("Verificaci√≥n: P(X > %d) = %.4f (< 5%%)\n", S_b, 1 - ppois(S_b, lambda = lambda)))
cat("--------------------------------\n\n")

## c & d. Costo Esperado y Nivel √ìptimo de Inventario
Ca <- 10 # Costo de Adquisici√≥n
Cm <- 2  # Costo de Mantenimiento
Cp <- 15 # Costo de Venta Perdida

# Regla del Cuantil Cr√≠tico
prob_critica <- Cp / (Cm + Cp)

# Determinar el nivel √≥ptimo de inventario (S*)
S_optimo <- qpois(prob_critica, lambda = lambda)

cat("## d. Nivel √ìptimo de Inventario que Minimiza el Costo\n")
cat(sprintf("Costo Cr√≠tico: Cp / (Cm + Cp) = 15 / (2 + 15) = %.4f\n", prob_critica))
cat(sprintf("Nivel √ìptimo de Inventario (S*): %d unidades\n", S_optimo))
cat("--------------------------------\n\n")

# c. Calcular el Costo Esperado M√≠nimo en S=11 (Verificaci√≥n)
costo_esperado <- function(S, lambda, Ca, Cm, Cp) {
  # 1. Costo de Adquisici√≥n
  costo_adq <- Ca * S

  # 2. Costo Esperado de Mantenimiento E[max(S - X, 0)]
  x_mant <- 0:(S - 1)
  prob_mant <- dpois(x_mant, lambda = lambda)
  exceso <- S - x_mant
  costo_mant_esperado <- Cm * sum(exceso * prob_mant)

  # 3. Costo Esperado de Falta de Stock E[max(X - S, 0)]
  # Usamos un rango amplio (hasta 40) para simular la suma infinita
  x_perdida <- (S + 1):40
  prob_perdida <- dpois(x_perdida, lambda = lambda)
  deficit <- x_perdida - S
  costo_perdida_esperado <- Cp * sum(deficit * prob_perdida)

  return(costo_adq + costo_mant_esperado + costo_perdida_esperado)
}

costo_minimo <- costo_esperado(S = S_optimo, lambda, Ca, Cm, Cp)

cat("## c. Costo Esperado Diario en el Nivel √ìptimo (S*=11)\n")
cat(sprintf("E[C(%d)] = $%.2f\n", S_optimo, costo_minimo))
cat("--------------------------------\n")
```
